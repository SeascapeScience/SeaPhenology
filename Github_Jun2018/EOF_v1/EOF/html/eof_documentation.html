
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>eof documentation</title><meta name="generator" content="MATLAB 8.0"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2017-02-01"><meta name="DC.source" content="eof_documentation.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1><tt>eof</tt> documentation</h1><!--introduction--><p>The <tt>eof</tt> function gives eigenmode maps of variability and corresponding principal component time series for spatiotemporal data analysis.  It is designed specifically for 3D matricies of data such as sea surface temperatures where dimensions 1 and 2 are spatial dimensions (e.g., lat and lon; lon and lat; x and y, etc.), and the third dimension represents different slices or snapshots of data in time.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Syntax</a></li><li><a href="#2">Description</a></li><li><a href="#3">A simple example</a></li><li><a href="#7">TUTORIAL: From raw climate reanalysis data to ENSO, PDO, etc.</a></li><li><a href="#9">Average sea surface temperature</a></li><li><a href="#10">Global warming</a></li><li><a href="#11">Remove the global warming signal</a></li><li><a href="#12">Remove seasonal cycles</a></li><li><a href="#17">Make a gif of the seasonal cycle</a></li><li><a href="#20">Calculate EOFs</a></li><li><a href="#22">Optional scaling of Principal Components and EOF maps</a></li><li><a href="#23">El Ni&ntilde;o Southern Oscillation (ENSO) time series</a></li><li><a href="#25">ENSO in the frequency domain</a></li><li><a href="#27">Maps of variability</a></li><li><a href="#29">Make a movie of SST variability from EOFs</a></li><li><a href="#32">How I got the sample data</a></li><li><a href="#33">References</a></li><li><a href="#34">Author Info</a></li></ul></div><h2>Syntax<a name="1"></a></h2><pre>eof_maps = eof(A)
eof_maps = eof(A,n)
eof_maps = eof(...,'mask',mask)
[eof_maps,pc,expvar] = eof(...)</pre><h2>Description<a name="2"></a></h2><p><tt>eof_maps = eof(A)</tt> calculates all modes of variability in <tt>A</tt>, where <tt>A</tt> is a 3D matrix whose first two dimensions are spatial, the third dimension is temporal, and data are assumed to be equally spaced in time.  Output <tt>eof_maps</tt> have the same dimensions as <tt>A</tt>, where each map along the third dimension represents a mode of variability order of importance.</p><p><tt>eof_maps = eof(A,n)</tt> only calculates the first <tt>n</tt> modes of variability. For large datasets, it's computationally faster to only calculate the number of modes you'll need.  If <tt>n</tt> is not specified, all EOFs are calculated (one for each time slice).</p><p><tt>eof_maps = eof(...,'mask',mask)</tt> only performs EOF analysis on the grid cells represented by ones in a logical <tt>mask</tt> whose dimensions correspond to dimensions 1 and 2 of <tt>A</tt>.  This option is provided to prevent solving for things that don't need to be solved, or to let you do analysis on one region separately from another.  By default, any grid cells in <tt>A</tt> which contain <i>any</i> NaNs are masked out.</p><p><tt>[eof_maps,pc,expvar] = eof(...)</tt> returns the principal component time series <tt>pc</tt> whose rows each represent a different mode from 1 to <tt>n</tt> and columns correspond to time steps.  For example, <tt>pc(1,:)</tt> is the time series of the first (dominant) mode of varibility.  The third output <tt>expvar</tt> is the percent of variance explained by each mode.</p><h2>A simple example<a name="3"></a></h2><p>Here's a quick example of how to use the <tt>eof</tt> function. Proper EOF analysis requires detrending and deseasoning the data before calculating EOFs, and those steps are described in the tutorial below, but for now let's just pretend this sample dataset is ready to be analyzed.  Load the sample data, then calculate the first EOF.</p><p>Here I'm plotting the first EOF map using the <a href="https://www.mathworks.com/matlabcentral/fileexchange/57773-cmocean-perceptually-uniform-colormaps/content/cmocean/html/cmocean_documentation.html"><tt>cmocean</tt></a> <i>delta</i> colormap (Thyng et al., 2016) with the <tt>'pivot'</tt> argument to ensure it's centered about zero.</p><pre class="codeinput"><span class="comment">% Load sample data:</span>
load <span class="string">PacOcean.mat</span>

<span class="comment">% Calculate the first EOF of sea surface temperatures and its</span>
<span class="comment">% principal component time series:</span>
[eofmap,pc] = eof(sst,1);

<span class="comment">% Plot the first EOF map:</span>
imagesc(lon,lat,eofmap);
axis <span class="string">xy</span> <span class="string">image</span> <span class="string">off</span>

<span class="comment">% Optional: Use a cmocean colormap:</span>
cmocean(<span class="string">'delta'</span>,<span class="string">'pivot'</span>,0)
</pre><img vspace="5" hspace="5" src="eof_documentation_01.png" alt=""> <p>That's the first EOF of the SST dataset, but since we haven't removed the seasonal cycle, the first EOF primarily represents seasonal variability.  As evidence that the pattern above is associated with the seasonal cycle, take a look at the corresponding principal component time series.</p><pre class="codeinput">figure
plot(t,pc)
axis <span class="string">tight</span>
xlim([datenum(<span class="string">'jan 1, 1990'</span>) datenum(<span class="string">'jan 1, 1995'</span>)])
datetick(<span class="string">'x'</span>,<span class="string">'keeplimits'</span>)
</pre><img vspace="5" hspace="5" src="eof_documentation_02.png" alt=""> <p>That looks pretty seasonal to me.  If you prefer to plot the anomaly time series in the common two-color shaded style, use the <a href="https://www.mathworks.com/matlabcentral/fileexchange/61327-anomaly/content/anomaly/html/anomaly_documentation.html"><tt>anomaly</tt></a> function available on File Exchange.</p><pre class="codeinput">anomaly(t,pc)
</pre><img vspace="5" hspace="5" src="eof_documentation_03.png" alt=""> <pre class="codeinput">clear
</pre><h2>TUTORIAL: From raw climate reanalysis data to ENSO, PDO, etc.<a name="7"></a></h2><p>The <tt>eof</tt> function comes with a sample dataset called <tt>PacOcean.mat</tt>, which is a downsampled subset of the Hadley Centre's HadISST sea surface temperature dataset.  At the end of this tutorial there's a section which describes how I imported the raw NetCDF data into Matlab and the process I used to subset it.  If you follow along with this tutorial from top to bottom you should be able to apply EOF analysis to any similar dataset.</p><p>If you haven't already loaded the sample dataset, load it now and get an idea of its contents by checking the names and sizes of the variables:</p><pre class="codeinput">load <span class="string">PacOcean.mat</span>
whos
</pre><pre class="codeoutput">  Name        Size                   Bytes  Class     Attributes

  lat        60x1                      480  double              
  lon        55x1                      440  double              
  sst        60x55x802            21172800  double              
  t         802x1                     6416  double              

</pre><p>So we have a 3D <tt>sst</tt> matrix whose dimensions correspond to lat x lon x time.  What time range, and what are the time steps, you ask?  Let's take a look at the first and last date, and the average time step:</p><pre class="codeinput">datestr(t([1 end]))
mean(diff(t))
</pre><pre class="codeoutput">ans =
15-Jan-1950 12:00:00
15-Oct-2016 12:00:00
ans =
   30.4370
</pre><h2>Average sea surface temperature<a name="9"></a></h2><p>Okay, so this is monthly data, centered on about the 15th of each month, from 1950 to 2016. To get a sense of what the dataset looks like, display the mean temperature over that time.  I'm using <a href="https://www.mathworks.com/matlabcentral/fileexchange/61293-imagescn"><tt>imagescn</tt></a>, which automatically makes NaN values transparent, but you can use <tt>imagesc</tt> instead. I'm also using the <a href="https://www.mathworks.com/matlabcentral/fileexchange/57773-cmocean-perceptually-uniform-colormaps/content/cmocean/html/cmocean_documentation.html"><tt>cmocean</tt></a> <i>thermal</i> colormap (Thyng et al., 2016):</p><pre class="codeinput">figure
imagescn(lon,lat,mean(sst,3));
axis <span class="string">xy</span> <span class="string">off</span>
cb = colorbar;
ylabel(cb,<span class="string">' mean temperature {\circ}C '</span>)
cmocean <span class="string">thermal</span>
</pre><img vspace="5" hspace="5" src="eof_documentation_04.png" alt=""> <h2>Global warming<a name="10"></a></h2><p>Is global warming real?  The <a href="https://www.mathworks.com/matlabcentral/fileexchange/46363"><tt>trend</tt></a> function lets us easily get the linear trend of temperature from 1950 to 2016.  Be sure to multiply the trend by 365.25 to convert from degrees per day to degrees per year:</p><pre class="codeinput">imagescn(lon,lat,365.25*trend(sst,t,3));
axis <span class="string">xy</span> <span class="string">off</span>
cb = colorbar;
ylabel(cb,<span class="string">' temperature trend {\circ}C/yr '</span>)
cmocean(<span class="string">'balance'</span>,<span class="string">'pivot'</span>)
</pre><img vspace="5" hspace="5" src="eof_documentation_05.png" alt=""> <h2>Remove the global warming signal<a name="11"></a></h2><p>The global warming trend is interesting, but EOF analysis is all about variablity, not long-term trends, so we must remove the trend by <a href="https://www.mathworks.com/matlabcentral/fileexchange/61328-detrend3"><tt>detrend3</tt></a>:</p><pre class="codeinput">sst = detrend3(sst,t);
</pre><h2>Remove seasonal cycles<a name="12"></a></h2><p>If you plot the temperature trend again, you'll see that it's all been reduced to zero, with perhaps a few eps of numerical noise.  Now that's an SST dataset that even Anthony Watts would approve of.</p><p>We have now detrended the SST dataset (which also removed the mean), but it still contains quite a bit of seasonal variability that should be removed before EOF analysis because we're not interested in seasonal signals. A quick way to remove the seasonal cycle from this monthly dataset is to determine the average SST at each grid cell for any given month. Start by getting the months corresponding to each time step in <tt>t</tt>.  We don't need the year or day, so I'll tilde (~) out the <tt>datevec</tt> outputs and only keep the month:</p><pre class="codeinput">[~,month,~] = datevec(t);
</pre><p>The <tt>month</tt> vector is the same size as <tt>t</tt>, but only has 12 unique values:</p><pre class="codeinput">unique(month)'
</pre><pre class="codeoutput">ans =
     1     2     3     4     5     6     7     8     9    10    11    12
</pre><p>Specifically, that means each time step is associated with one of the 12 months of the year.  How many time steps are associated with January?</p><pre class="codeinput">sum(month==1)
</pre><pre class="codeoutput">ans =
    67
</pre><p>There are 67 January SST maps in the full dataset, because it's a 67 year record.  For each month of the year, we can compute an average SST map for that month by finding the indices of all the time steps associated with that month.  Then remove the seasonal signal by subtracting the average of all 67 January SST maps from each January SST map.  This is what I mean:</p><pre class="codeinput"><span class="comment">% Preallocate a 3D matrix of monthly means:</span>
monthlymeans = nan(length(lat),length(lon),12);

<span class="comment">% Calculate the mean of all maps corresponding to each month, and subtract</span>
<span class="comment">% the monthly means from the sst dataset:</span>
<span class="keyword">for</span> k = 1:12

   <span class="comment">% Indices of month k:</span>
   ind = month==k;

   <span class="comment">% Mean SST for month k:</span>
   monthlymeans(:,:,k) = mean(sst(:,:,ind),3);

   <span class="comment">% Subtract the monthly mean:</span>
   sst(:,:,ind) = bsxfun(@minus,sst(:,:,ind),monthlymeans(:,:,k));

<span class="keyword">end</span>
</pre><p>I know, <a href="https://www.mathworks.com/help/matlab/ref/bsxfun.html"><tt>bsxfun</tt></a> is not intuitive.  New versions of Matlab will let you subtract a 2D <tt>monthlymeans</tt> matrix from a 3D <tt>sst</tt> dataset by implicit expansion, meaning you can just use the minus sign instead of <tt>bsxfun</tt>, but if your version of Matlab predates 2016 you'll have to use the <tt>bsxfun</tt> method shown above.</p><h2>Make a gif of the seasonal cycle<a name="17"></a></h2><p>We just removed the seasonal cycle, but it was done in a loop and we didn't get to see exactly what information was being taken out of our <tt>sst</tt> dataset.  So let's make a gif using <a href="https://www.mathworks.com/matlabcentral/fileexchange/23629"><tt>export_fig</tt></a>.</p><pre>% First frame:
figure
h = imagescn(lon,lat,monthlymeans(:,:,1));
axis xy image off
cb = colorbar;
caxis([-10 10])
cmocean balance</pre><pre>title(datestr(datenum(1,1,1),'mmmm'))</pre><pre>export_fig temp.tif -append -nocrop</pre><pre>% Loop through all other frames:
for k = 2:12
   set(h,'cdata',monthlymeans(:,:,k))
   caxis([-10 10])
   title(datestr(datenum(1,k,1),'mmmm'))</pre><pre>   export_fig temp.tif -append -nocrop
end</pre><pre>im2gif('temp.tif','SeasonalTemperatureAnomalies.gif','-delay',0.1,'-nocrop')</pre><p><img vspace="5" hspace="5" src="SeasonalTemperatureAnomalies.gif" alt=""> </p><p>So now our <tt>sst</tt> dataset has been detrended, the mean removed, and the seasonal cycle removed. All that's left in <tt>sst</tt> are the anomalies--things that change, but are not long-term trends or short-term annual cycles.  Here's the remaining variance of our <tt>sst</tt> anomaly dataset:</p><pre class="codeinput">figure
imagescn(lon,lat,var(sst,[],3));
axis <span class="string">xy</span> <span class="string">off</span>
colorbar
title(<span class="string">'variance of temperature'</span>)
colormap(jet)
caxis([0 1])
</pre><img vspace="5" hspace="5" src="eof_documentation_06.png" alt=""> <p>And the map above lines up quite well with Figure 2a of <a href="http://dx.doi.org/10.1175/2011JCLI3941.1">Messie and Chavez (2011)</a>, which tells us we're on the right track.</p><h2>Calculate EOFs<a name="20"></a></h2><p>EOF analysis tells us not only where things vary, but how often, and what regions tend to vary together or out of phase with each other.  With our detrended, deseasoned <tt>sst</tt> dataset, EOF analysis is mighty simple via the <tt>eof</tt> function:</p><pre class="codeinput">[eof_maps,pc,expv] = eof(sst);
</pre><p>Eigenvector analysis has a funny behavior that can produce EOF maps which are positive or negative, and the solutions can come up different every time using the same exact inputs. Positive and negative solutions are equally valid -- think of the modes of vibration of a drum head where some regions of the drum head go up while other regions go down, and then they switch -- and likewise the eigenvalue solutions of SST variability might be positive or negative.  The only thing that matters is that when we reconstruct a time series from an EOF solution, we multiply each EOF map by its corresponding principal component (<tt>pc</tt>).</p><p>I've written the <tt>eof</tt> function to produce consistent results each time you run it with the same data, but don't worry if the sign of a solution does not match the sign of someone else's results--that just means they picked the other solution, and that's perfectly fine.</p><p>Just as EOF maps can have positive or negative solutions and both are equally valid, there's some flexibility in how the magnitudes of EOF maps are displayed.  You can multiply the magnitude of an EOF map by any value you want, just as long as you divide the corresponding principal component time series by the same value.  Let's take a look at the time series of the first three modes of variability:</p><pre class="codeinput">figure
plot(t,pc(1:3,:)')
box <span class="string">off</span>
axis <span class="string">tight</span>
datetick(<span class="string">'x'</span>,<span class="string">'keeplimits'</span>)
legend(<span class="string">'pc1'</span>,<span class="string">'pc2'</span>,<span class="string">'pc3'</span>)
</pre><img vspace="5" hspace="5" src="eof_documentation_07.png" alt=""> <h2>Optional scaling of Principal Components and EOF maps<a name="22"></a></h2><p>Those principal component time series are fine just the way they are, but some folks prefer to scale each time series to span a desired range.  Looking at Figure 5 of <a href="http://dx.doi.org/10.1175/2011JCLI3941.1">Messie and Chavez (2011)</a>, it seems they chose to scale each principal component time series such that it spans the range -1 to 1.  Let's do the same thing, divide each principal component time series by its maximum value and don't forget to multiply the corresponding EOF map by the same value:</p><pre class="codeinput"><span class="keyword">for</span> k = 1:size(pc,1)

   <span class="comment">% Find the index of the maximum value in the time series:</span>
   [maxval,ind] = max(abs(pc(k,:)));

   <span class="comment">% Divide the time series by its maximum value:</span>
   pc(k,:) = pc(k,:)/maxval;

   <span class="comment">% Multiply the corresponding EOF map:</span>
   eof_maps(:,:,k) = eof_maps(:,:,k)*maxval;

<span class="keyword">end</span>
</pre><h2>El Ni&ntilde;o Southern Oscillation (ENSO) time series<a name="23"></a></h2><p>The first mode of detrended, deseasoned SSTs is assoiciated with ENSO.  We can plot the time series again as a simple line plot, but anomaly plots are often filled in.  Let's use <a href="https://www.mathworks.com/matlabcentral/fileexchange/61327-anomaly/content/anomaly/html/anomaly_documentation.html"><tt>anomaly</tt></a> to plot the first mode, and multiply by -1 to match the sign of Figure 5 of <a href="http://dx.doi.org/10.1175/2011JCLI3941.1">Messie and Chavez (2011)</a>.</p><pre class="codeinput">figure(<span class="string">'pos'</span>,[100 100 600 250])
anomaly(t,-pc(1,:)) <span class="comment">% First principal component is enso</span>
box <span class="string">off</span>
axis <span class="string">tight</span>
datetick(<span class="string">'x'</span>,<span class="string">'keeplimits'</span>)
text([724316 729713 736290],[.95 .99 .81],<span class="string">'El Nino'</span>,<span class="string">'horiz'</span>,<span class="string">'center'</span>)
</pre><img vspace="5" hspace="5" src="eof_documentation_08.png" alt=""> <p>Sure enough, some of the <a href="https://en.wikipedia.org/wiki/El_Ni%C3%B1o">strongest El Nino events on record</a> took place in 1982-1983, 1997-1998, and 2014-2016.</p><h2>ENSO in the frequency domain<a name="25"></a></h2><p>Sometimes we hear that El Nino has a characteristic frequency of once every five years, or five to seven years, or sometimes you hear it's every two to seven years.  It's hard to see that in the time series, so we plot the first principal component in the frequency domain with <a href="https://www.mathworks.com/matlabcentral/fileexchange/53533-plotpsd/content/plotpsd/html/plotpsd_documentation.html"><tt>plotpsd</tt></a>, specifying a sampling frequency of 12 samples per year, plotted on a log x axis, with x values in units of lambda (years) rather than frequency:</p><pre class="codeinput">figure
plotpsd(pc(1,:),12,<span class="string">'logx'</span>,<span class="string">'lambda'</span>)
xlabel <span class="string">'periodicity (years)'</span>
set(gca,<span class="string">'xtick'</span>,[1:7 33])
</pre><img vspace="5" hspace="5" src="eof_documentation_09.png" alt=""> <p>As you can see, the ENSO signal does not have a sharply defined resonance frequency, but there's energy in that whole two-to-seven year range. I also labeled the 33 year periodicity because that's Nyquist for this particular dataset--any energy with a longer period than Nyquist (or anywhere near it) should probably be considered junk.</p><h2>Maps of variability<a name="27"></a></h2><p>EOFs aren't just about time series--they're about spatial patterns of variability through time. Each mode has a characteristic pattern of variability just like the different modes of vibration of a drum head. At any given time, the different modes can be summed to create a total picture of temperature anomalies at that time.  The <i>orthogonal</i> part of Empirical Orthogonal Function means each of the modes tend to do their own thing, independent of the other modes.  Let's look at the first six modes by recreating Figure 4 of <a href="http://dx.doi.org/10.1175/2011JCLI3941.1">Messie and Chavez (2011)</a> .  I'm multiplying some of the modes by negative one because I want to match their signs, and remember, we can do that.</p><pre class="codeinput">s = [-1 1 -1 1 -1 1]; <span class="comment">% (sign multiplier to match Messie and Chavez 2011)</span>

figure(<span class="string">'pos'</span>,[100 100 500 700])
<span class="keyword">for</span> k = 1:6
   subplot(3,2,k)
   imagescn(lon,lat,eof_maps(:,:,k)*s(k));
   axis <span class="string">xy</span> <span class="string">off</span>
   title([<span class="string">'Mode '</span>,num2str(k),<span class="string">' ('</span>,num2str(expv(k)),<span class="string">'%)'</span>])
   caxis([-2 2])
<span class="keyword">end</span>

colormap <span class="string">jet</span>
</pre><img vspace="5" hspace="5" src="eof_documentation_10.png" alt=""> <p>The percent variance explained by each mode does match Messie and Chavez because we're using a much shorter time series than they did and we're also using a spatial subset of the world data.  Nonetheless, patterns generally agree.</p><p>The <tt>jet</tt> colormap is not exactly the same one used by Messie and Chavez, which explains why some of the patterns above may look slightly different from Messie and Chavez.  But since we're talking about colormaps, rainbows are actually quite bad at representing numerical data (Thyng et al, 2016), and given that these maps represent anomalies, and these anomaly maps are better represented by a divergent colormap that gives equal weight to each side of zero:</p><pre class="codeinput">cmocean <span class="string">balance</span>
</pre><img vspace="5" hspace="5" src="eof_documentation_11.png" alt=""> <h2>Make a movie of SST variability from EOFs<a name="29"></a></h2><p>At any given time, a snapshot of sea surface temperature anomalies associated with ENSO can be obtained by plotting the map of mode 1 shown above, multiplied by its corresponding principal component (the vector <tt>pc(1,:)</tt>) at that time.  Similarly, you can get a picture of worldwide sea surface temperature anomalies at a given time by summing all the EOF maps, each multiplied by their corresponding principal component at that time.  In this way we can build a more-and-more complete movie of SST anomalies as we include more and more more modes of variability.  By the same notion, modes can be excluded to filter out undesired signals, or we can just use the first few modes as a way of filtering-out noise.  Let's make a movie of the first three modes, from 1990 to 2005:</p><pre>% Indices of start and end dates for the movie:
startind = find(t&gt;=datenum('jan 1, 1990'),1,'first');
endind = find(t&lt;=datenum('dec 31, 1999'),1,'last');</pre><pre>% A map of SST anomalies from first three modes at start:
map = eof_maps(:,:,1)*pc(1,startind) + ... % Mode 1, Jan 1990
      eof_maps(:,:,2)*pc(2,startind) + ... % Mode 2, Jan 1990
      eof_maps(:,:,3)*pc(3,startind);      % Mode 3, Jan 1990</pre><pre>% Create the first frame of the movie:
figure
h = imagescn(lon,lat,map);
axis xy image off
cb = colorbar;
caxis([-2 2])
cmocean balance
title(datestr(t(startind),'yyyy'))</pre><pre>export_fig temp.tif -append -nocrop</pre><pre>for k = (startind+1):endind</pre><pre>   % Update the map for date k
   map = eof_maps(:,:,1)*pc(1,k) + ... % Mode 1
         eof_maps(:,:,2)*pc(2,k) + ... % Mode 2
         eof_maps(:,:,3)*pc(3,k);      % Mode 3</pre><pre>   set(h,'cdata',map)
   caxis([-2 2])
   title(datestr(t(k),'yyyy'))</pre><pre>   export_fig temp.tif -append -nocrop
end</pre><pre>im2gif('temp.tif','SSTs_1990s.gif','-delay',1/12,'-nocrop')</pre><p><img vspace="5" hspace="5" src="SSTs_1990s.gif" alt=""> </p><p>The first thing you probably notice is that the 1990s SST anomaly time series is dominated by ENSO, and check out that 1997-1998 signal!  No wonder it was such a hot topic in the <a href="http://www.nbc.com/saturday-night-live/video/el-nino/2861308?snl=1">news</a> that year.  But it's important to remember that the movie above is not a complete reconstruction of the SST anomalies, but rather only the first three modes, which together account for</p><pre class="codeinput">sum(expv(1:3))
</pre><pre class="codeoutput">ans =
   51.7000
</pre><p>...just over half of the total variance of the SST dataset. To reconstruct the absolute temperature field rather than just anomalies from the first three modes, you'd need to include all the EOF maps, and you'd also have to add back in the mean SST map, the trend, and the seasonal cycle.</p><h2>How I got the sample data<a name="32"></a></h2><p>The example dataset shown above comes from the Hadley Center HadISST, found <a href="http://www.metoffice.gov.uk/hadobs/hadisst/data/download.html">here</a> (Rayner et al., 2003) which in full exceeds 200 MB.  If you'd like to perform the the same kind of analysis on a different region of the world, you can download the HadISST_sst.nc dataset and import it into Matlab like this.  Downsampling or subsetting the dataset are up to you:</p><pre>% Load the full SST dataset:
lat = double(ncread('HadISST_sst.nc','latitude'));
lon = double(ncread('HadISST_sst.nc','longitude'));
t = double(ncread('HadISST_sst.nc','time')+datenum(1870,1,0));
sst = ncread('HadISST_sst.nc','sst');</pre><pre>% To quarter the size of the sample dataset, I crudely downsample to every other grid point:
sst = sst(1:2:end,1:2:end,:);
lat = lat(1:2:end);
lon = lon(1:2:end);</pre><pre>% To further reduce size, I clipped to a range of lats and lons and kept only post-1950 data:
rows = lon&lt;-70;
lon = lon(rows);
cols = lat&gt;=-60 &amp; lat&lt;=60;
lat = lat(cols);
times = t&gt;=datenum('jan 1, 1950');
t = t(times);
sst = sst(rows,cols,times);
sst(sst&lt;-50) = NaN;</pre><pre>% I find it easier to rearrange as lat x lon x time:
sst = permute(sst,[2 1 3]);</pre><pre>% Save the sample data:
save('PacOcean.mat','lat','lon','t','sst')</pre><h2>References<a name="33"></a></h2><p>Messi&eacute;, Monique, and Francisco Chavez. "Global modes of sea surface temperature variability in relation to regional climate indices." Journal of Climate 24.16 (2011): 4314-4331. <a href="http://dx.doi.org/10.1175/2011JCLI3941.1">doi:10.1175/2011JCLI3941.1</a>.</p><p>Rayner, N. A., Parker, D. E., Horton, E. B., Folland, C. K., Alexander, L. V., Rowell, D. P., Kent, E. C., Kaplan, A. (2003). Global analyses of sea surface temperature, sea ice, and night marine air temperature since the late nineteenth century. J. Geophys. Res.Vol. 108, No. D14, 4407 <a href="http://dx.doi.org/10.1029/2002JD002670">doi:10.1029/2002JD002670</a>.</p><p>Thyng, K.M., C.A. Greene, R.D. Hetland, H.M. Zimmerle, and S.F. DiMarco. 2016. True colors of oceanography: Guidelines for effective and accurate colormap selection. Oceanography 29(3):9-13, <a href="http://dx.doi.org/10.5670/oceanog.2016.66">doi:10.5670/oceanog.2016.66</a>.</p><h2>Author Info<a name="34"></a></h2><p>The <tt>eof</tt> function was written by <a href="http://www.chadagreene.com">Chad A. Greene</a> of the University of Texas Institute for Geophysics (UTIG) in January 2017, but leans heavily on Guillame MAZE's <tt>caleof</tt> function from his <a href="https://www.mathworks.com/matlabcentral/fileexchange/17915">PCATool</a> contribution. This tutorial was written by Chad Greene with help from <a href="https://www.kaustubh.info/">Kaustubh Thirumalai</a> also of the University of Texas Institute for Geophysics.</p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2012b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% |eof| documentation
% The |eof| function gives eigenmode maps of variability and corresponding principal component
% time series for spatiotemporal data analysis.  It is designed specifically for 3D matricies
% of data such as sea surface temperatures where dimensions 1 and 2 are spatial dimensions 
% (e.g., lat and lon; lon and lat; x and y, etc.), and the third dimension represents different 
% slices or snapshots of data in time.  
% 
%% Syntax
% 
%  eof_maps = eof(A) 
%  eof_maps = eof(A,n) 
%  eof_maps = eof(...,'mask',mask) 
%  [eof_maps,pc,expvar] = eof(...)
% 
%% Description 
% 
% |eof_maps = eof(A)| calculates all modes of variability in |A|, where |A| is a 3D matrix whose
% first two dimensions are spatial, the third dimension is temporal, and data are assumed to be 
% equally spaced in time.  Output |eof_maps| have the same dimensions as |A|, where each map along 
% the third dimension represents a mode of variability order of importance. 
% 
% |eof_maps = eof(A,n)| only calculates the first |n| modes of variability. For large datasets, 
% it's computationally faster to only calculate the number of modes you'll need.  If |n| is not
% specified, all EOFs are calculated (one for each time slice). 
% 
% |eof_maps = eof(...,'mask',mask)| only performs EOF analysis on the grid cells represented by 
% ones in a logical |mask| whose dimensions correspond to dimensions 1 and 2 of |A|.  This option
% is provided to prevent solving for things that don't need to be solved, or to let you do analysis
% on one region separately from another.  By default, any grid cells in |A| which contain _any_ NaNs 
% are masked out.  
% 
% |[eof_maps,pc,expvar] = eof(...)| returns the principal component time series |pc| whose rows
% each represent a different mode from 1 to |n| and columns correspond to time steps.  For example, 
% |pc(1,:)| is the time series of the first (dominant) mode of varibility.  The third output |expvar| 
% is the percent of variance explained by each mode.  
% 
%% A simple example
% Here's a quick example of how to use the |eof| function. Proper EOF analysis requires detrending
% and deseasoning the data before calculating EOFs, and those steps are described in the tutorial 
% below, but for now let's just pretend this sample dataset is ready to be analyzed.  Load
% the sample data, then calculate the first EOF.  
% 
% Here I'm plotting the first EOF map using the <https://www.mathworks.com/matlabcentral/fileexchange/57773-cmocean-perceptually-uniform-colormaps/content/cmocean/html/cmocean_documentation.html
% |cmocean|> _delta_ colormap (Thyng et al., 2016) with the |'pivot'| argument to ensure it's centered about zero. 

% Load sample data: 
load PacOcean.mat

% Calculate the first EOF of sea surface temperatures and its 
% principal component time series: 
[eofmap,pc] = eof(sst,1); 

% Plot the first EOF map: 
imagesc(lon,lat,eofmap); 
axis xy image off

% Optional: Use a cmocean colormap:
cmocean('delta','pivot',0)

%% 
% That's the first EOF of the SST dataset, but since we haven't removed the seasonal cycle, 
% the first EOF primarily represents seasonal variability.  As evidence that the pattern
% above is associated with the seasonal cycle, take a look at the corresponding principal component 
% time series.
 
figure
plot(t,pc) 
axis tight
xlim([datenum('jan 1, 1990') datenum('jan 1, 1995')])
datetick('x','keeplimits')

%% 
% That looks pretty seasonal to me.  If you prefer to plot the anomaly time series in the common two-color 
% shaded style, use the <https://www.mathworks.com/matlabcentral/fileexchange/61327-anomaly/content/anomaly/html/anomaly_documentation.html
% |anomaly|> function available on File Exchange. 

anomaly(t,pc) 

%% 
clear
%% TUTORIAL: From raw climate reanalysis data to ENSO, PDO, etc.
% The |eof| function comes with a sample dataset called |PacOcean.mat|, which is a downsampled subset 
% of the Hadley Centre's HadISST sea surface temperature dataset.  At the end of this tutorial there's 
% a section which describes how I imported the raw NetCDF data into Matlab and the process I used 
% to subset it.  If you follow along with this tutorial from top to bottom you should be able to 
% apply EOF analysis to any similar dataset.  
% 
% If you haven't already loaded the sample dataset, load it now and get an idea of its contents
% by checking the names and sizes of the variables: 

load PacOcean.mat
whos

%% 
% So we have a 3D |sst| matrix whose dimensions correspond to lat x lon x time.  What time range, 
% and what are the time steps, you ask?  Let's take a look at the first and last date, and the
% average time step: 

datestr(t([1 end]))
mean(diff(t))

%% Average sea surface temperature
% Okay, so this is monthly data, centered on about the 15th of each month, from 1950 to 2016. To get
% a sense of what the dataset looks like, display the mean temperature over that time.  I'm using
% <https://www.mathworks.com/matlabcentral/fileexchange/61293-imagescn |imagescn|>, which automatically
% makes NaN values transparent, but you can use |imagesc| instead. I'm also using the <https://www.mathworks.com/matlabcentral/fileexchange/57773-cmocean-perceptually-uniform-colormaps/content/cmocean/html/cmocean_documentation.html
% |cmocean|> _thermal_ colormap (Thyng et al., 2016): 

figure
imagescn(lon,lat,mean(sst,3)); 
axis xy off
cb = colorbar; 
ylabel(cb,' mean temperature {\circ}C ') 
cmocean thermal

%% Global warming
% Is global warming real?  The <https://www.mathworks.com/matlabcentral/fileexchange/46363 |trend|> function
% lets us easily get the linear trend of temperature from 1950 to 2016.  Be sure to multiply the trend by 365.25
% to convert from degrees per day to degrees per year: 

imagescn(lon,lat,365.25*trend(sst,t,3)); 
axis xy off
cb = colorbar; 
ylabel(cb,' temperature trend {\circ}C/yr ') 
cmocean('balance','pivot') 

%% Remove the global warming signal
% The global warming trend is interesting, but EOF analysis is all about variablity, not long-term trends, so
% we must remove the trend by <https://www.mathworks.com/matlabcentral/fileexchange/61328-detrend3 |detrend3|>: 

sst = detrend3(sst,t); 

%% Remove seasonal cycles 
% If you plot the temperature trend again, you'll see that it's all been reduced to zero, with perhaps a few eps 
% of numerical noise.  Now that's an SST dataset that even Anthony Watts would approve of.  
% 
% We have now detrended the SST dataset (which also removed the mean), but it still contains quite a bit of seasonal 
% variability that should be removed before EOF analysis because we're not interested in seasonal signals. A quick way 
% to remove the seasonal cycle from this monthly dataset is to determine the average SST at each grid cell for any given month. 
% Start by getting the months corresponding to each time step in |t|.  We don't need the year or day, so I'll tilde (~) out 
% the |datevec| outputs and only keep the month: 

[~,month,~] = datevec(t); 

%% 
% The |month| vector is the same size as |t|, but only has 12 unique values: 

unique(month)'

%% 
% Specifically, that means each time step is associated with one of the 12 months of the year.  How many 
% time steps are associated with January? 

sum(month==1)

%% 
% There are 67 January SST maps in the full dataset, because it's a 67 year record.  For each month
% of the year, we can compute an average SST map for that month by finding the indices of all the time steps
% associated with that month.  Then remove the seasonal signal by subtracting the average of all 67 January 
% SST maps from each January SST map.  This is what I mean: 

% Preallocate a 3D matrix of monthly means: 
monthlymeans = nan(length(lat),length(lon),12); 

% Calculate the mean of all maps corresponding to each month, and subtract
% the monthly means from the sst dataset: 
for k = 1:12
   
   % Indices of month k: 
   ind = month==k; 
   
   % Mean SST for month k: 
   monthlymeans(:,:,k) = mean(sst(:,:,ind),3); 
   
   % Subtract the monthly mean: 
   sst(:,:,ind) = bsxfun(@minus,sst(:,:,ind),monthlymeans(:,:,k));
   
end

%% 
% I know, <https://www.mathworks.com/help/matlab/ref/bsxfun.html |bsxfun|> is not intuitive.  New versions
% of Matlab will let you subtract a 2D |monthlymeans| matrix from a 3D |sst| dataset by implicit expansion, 
% meaning you can just use the minus sign instead of |bsxfun|, but if your version of Matlab predates 2016
% you'll have to use the |bsxfun| method shown above. 

%% Make a gif of the seasonal cycle
% We just removed the seasonal cycle, but it was done in a loop and we didn't get to see exactly what 
% information was being taken out of our |sst| dataset.  So let's make a gif using <https://www.mathworks.com/matlabcentral/fileexchange/23629 |export_fig|>.
% 
%  % First frame:
%  figure
%  h = imagescn(lon,lat,monthlymeans(:,:,1)); 
%  axis xy image off
%  cb = colorbar; 
%  caxis([-10 10]) 
%  cmocean balance
%  
%  title(datestr(datenum(1,1,1),'mmmm'))
%  
%  export_fig temp.tif -append -nocrop
%  
%  % Loop through all other frames:
%  for k = 2:12
%     set(h,'cdata',monthlymeans(:,:,k))
%     caxis([-10 10]) 
%     title(datestr(datenum(1,k,1),'mmmm'))
%     
%     export_fig temp.tif -append -nocrop
%  end
%  
%  im2gif('temp.tif','SeasonalTemperatureAnomalies.gif','-delay',0.1,'-nocrop')
%
% <<SeasonalTemperatureAnomalies.gif>>
% 
%% 
% So now our |sst| dataset has been detrended, the mean removed, and the seasonal cycle removed. 
% All that's left in |sst| are the anomaliesREPLACE_WITH_DASH_DASHthings that change, but are not long-term trends
% or short-term annual cycles.  Here's the remaining variance of our |sst| anomaly dataset: 

figure
imagescn(lon,lat,var(sst,[],3)); 
axis xy off
colorbar
title('variance of temperature') 
colormap(jet)
caxis([0 1])

%% 
% And the map above lines up quite well with Figure 2a of <http://dx.doi.org/10.1175/2011JCLI3941.1 Messie and Chavez (2011)>, 
% which tells us we're on the right track. 

%% Calculate EOFs
% EOF analysis tells us not only where things vary, but how often, and what regions tend to vary together
% or out of phase with each other.  With our detrended, deseasoned |sst| dataset, EOF analysis is
% mighty simple via the |eof| function: 

[eof_maps,pc,expv] = eof(sst); 

%% 
% Eigenvector analysis has a funny behavior that can produce EOF maps which are positive 
% or negative, and the solutions can come up different every time using the same exact inputs. 
% Positive and negative solutions are equally valid REPLACE_WITH_DASH_DASH think of the modes of vibration of a 
% drum head where some regions of the drum head go up while other regions go down, and then 
% they switch REPLACE_WITH_DASH_DASH and likewise the eigenvalue solutions of SST variability might be positive
% or negative.  The only thing that matters is that when we reconstruct a time series from 
% an EOF solution, we multiply each EOF map by its corresponding principal component (|pc|). 
% 
% I've written the |eof| function to produce consistent results each time you run it with 
% the same data, but don't worry if the sign of a solution does not match the sign of someone 
% else's resultsREPLACE_WITH_DASH_DASHthat just means they picked the other solution, and that's perfectly fine.  
% 
% Just as EOF maps can have positive or negative solutions and both are equally valid, there's
% some flexibility in how the magnitudes of EOF maps are displayed.  You can multiply the magnitude
% of an EOF map by any value you want, just as long as you divide the corresponding principal component
% time series by the same value.  Let's take a look at the time series of the first three modes
% of variability: 

figure
plot(t,pc(1:3,:)')
box off 
axis tight
datetick('x','keeplimits')
legend('pc1','pc2','pc3')

%% Optional scaling of Principal Components and EOF maps
% Those principal component time series are fine just the way they are, but some folks prefer
% to scale each time series to span a desired range.  Looking at Figure 5 of <http://dx.doi.org/10.1175/2011JCLI3941.1 Messie and Chavez (2011)>, 
% it seems they chose to scale each principal component time series such that it spans the
% range -1 to 1.  Let's do the same thing, divide each principal component time series by its
% maximum value and don't forget to multiply the corresponding EOF map by the same value: 

for k = 1:size(pc,1) 
   
   % Find the index of the maximum value in the time series: 
   [maxval,ind] = max(abs(pc(k,:))); 
   
   % Divide the time series by its maximum value: 
   pc(k,:) = pc(k,:)/maxval; 
   
   % Multiply the corresponding EOF map: 
   eof_maps(:,:,k) = eof_maps(:,:,k)*maxval; 
   
end

%% El Ni√±o Southern Oscillation (ENSO) time series
% The first mode of detrended, deseasoned SSTs is assoiciated with ENSO.  We can plot the 
% time series again as a simple line plot, but anomaly plots are often filled in.  Let's use 
% <https://www.mathworks.com/matlabcentral/fileexchange/61327-anomaly/content/anomaly/html/anomaly_documentation.html |anomaly|> 
% to plot the first mode, and multiply by -1 to match the sign of Figure 5 of <http://dx.doi.org/10.1175/2011JCLI3941.1 Messie and Chavez (2011)>. 

figure('pos',[100 100 600 250]) 
anomaly(t,-pc(1,:)) % First principal component is enso
box off
axis tight
datetick('x','keeplimits') 
text([724316 729713 736290],[.95 .99 .81],'El Nino','horiz','center')

%%
% Sure enough, some of the <https://en.wikipedia.org/wiki/El_Ni%C3%B1o strongest El Nino events on record>
% took place in 1982-1983, 1997-1998, and 2014-2016.  

%% ENSO in the frequency domain
% Sometimes we hear that El Nino has a characteristic frequency of once every five years, or five to seven years, 
% or sometimes you hear it's every two to seven years.  It's hard to see that in the time series, so we plot the first principal component in 
% the frequency domain with <https://www.mathworks.com/matlabcentral/fileexchange/53533-plotpsd/content/plotpsd/html/plotpsd_documentation.html |plotpsd|>, 
% specifying a sampling frequency of 12 samples per year, plotted on a log x axis, with x values in 
% units of lambda (years) rather than frequency: 

figure
plotpsd(pc(1,:),12,'logx','lambda')
xlabel 'periodicity (years)'
set(gca,'xtick',[1:7 33])

%% 
% As you can see, the ENSO signal does not have a sharply defined resonance frequency, 
% but there's energy in that whole two-to-seven year range. I also labeled the 33 year
% periodicity because that's Nyquist for this particular datasetREPLACE_WITH_DASH_DASHany energy with a longer
% period than Nyquist (or anywhere near it) should probably be considered junk. 

%% Maps of variability
% EOFs aren't just about time seriesREPLACE_WITH_DASH_DASHthey're about spatial patterns of variability through time. Each mode
% has a characteristic pattern of variability just like the different modes of vibration of a drum head. At 
% any given time, the different modes can be summed to create a total picture of temperature anomalies at 
% that time.  The _orthogonal_ part of Empirical Orthogonal Function means each of the modes tend to do their
% own thing, independent of the other modes.  Let's look at the first six modes by recreating Figure 4 of 
% <http://dx.doi.org/10.1175/2011JCLI3941.1 Messie and Chavez (2011)> .  I'm multiplying some of the modes
% by negative one because I want to match their signs, and remember, we can do that. 

s = [-1 1 -1 1 -1 1]; % (sign multiplier to match Messie and Chavez 2011)

figure('pos',[100 100 500 700])
for k = 1:6
   subplot(3,2,k) 
   imagescn(lon,lat,eof_maps(:,:,k)*s(k)); 
   axis xy off
   title(['Mode ',num2str(k),' (',num2str(expv(k)),'%)'])
   caxis([-2 2]) 
end

colormap jet

%% 
% The percent variance explained by each mode does match Messie and Chavez because we're using a much shorter
% time series than they did and we're also using a spatial subset of the world data.  Nonetheless, 
% patterns generally agree.  
% 
% The |jet| colormap is not exactly the same one used by Messie and Chavez, which explains why some of the patterns
% above may look slightly different from Messie and Chavez.  But since we're talking about colormaps, rainbows are 
% actually quite bad at representing numerical data (Thyng et al, 2016), and given that these maps represent anomalies, 
% and these anomaly maps are better represented by a divergent colormap that gives equal weight to each side of zero: 

cmocean balance 

%% Make a movie of SST variability from EOFs
% At any given time, a snapshot of sea surface temperature anomalies associated with 
% ENSO can be obtained by plotting the map of mode 1 shown above, multiplied by its
% corresponding principal component (the vector |pc(1,:)|) at that time.  Similarly, 
% you can get a picture of worldwide sea surface temperature anomalies at a given time
% by summing all the EOF maps, each multiplied by their corresponding principal component
% at that time.  In this way we can build a more-and-more complete movie of SST anomalies
% as we include more and more more modes of variability.  By the same notion, modes can 
% be excluded to filter out undesired signals, or we can just use the first few modes 
% as a way of filtering-out noise.  Let's make a movie of the first three modes, from 1990 to 2005: 
% 
%  % Indices of start and end dates for the movie: 
%  startind = find(t>=datenum('jan 1, 1990'),1,'first'); 
%  endind = find(t<=datenum('dec 31, 1999'),1,'last'); 
%  
%  % A map of SST anomalies from first three modes at start:
%  map = eof_maps(:,:,1)*pc(1,startind) + ... % Mode 1, Jan 1990
%        eof_maps(:,:,2)*pc(2,startind) + ... % Mode 2, Jan 1990
%        eof_maps(:,:,3)*pc(3,startind);      % Mode 3, Jan 1990
%  
%  % Create the first frame of the movie:   
%  figure
%  h = imagescn(lon,lat,map); 
%  axis xy image off
%  cb = colorbar; 
%  caxis([-2 2]) 
%  cmocean balance
%  title(datestr(t(startind),'yyyy'))
%  
%  export_fig temp.tif -append -nocrop
%  
%  for k = (startind+1):endind
%     
%     % Update the map for date k
%     map = eof_maps(:,:,1)*pc(1,k) + ... % Mode 1
%           eof_maps(:,:,2)*pc(2,k) + ... % Mode 2
%           eof_maps(:,:,3)*pc(3,k);      % Mode 3
%  
%     set(h,'cdata',map)
%     caxis([-2 2]) 
%     title(datestr(t(k),'yyyy'))
%     
%     export_fig temp.tif -append -nocrop
%  end
%  
%  im2gif('temp.tif','SSTs_1990s.gif','-delay',1/12,'-nocrop')
%  
% <<SSTs_1990s.gif>>
% 
%% 
% The first thing you probably notice is that the 1990s SST anomaly time series is dominated by ENSO, 
% and check out that 1997-1998 signal!  No wonder it was such a hot topic in the <http://www.nbc.com/saturday-night-live/video/el-nino/2861308?snl=1
% news> that year.  But it's important to remember that the movie above is not a complete reconstruction of 
% the SST anomalies, but rather only the first three modes, which together account for 

sum(expv(1:3))

%% 
% ...just over half of the total variance of the SST dataset. To reconstruct the absolute temperature field rather than 
% just anomalies from the first three modes, you'd need to include all the EOF maps, and you'd also 
% have to add back in the mean SST map, the trend, and the seasonal cycle.  

%% How I got the sample data
% The example dataset shown above comes from the Hadley Center HadISST, found <http://www.metoffice.gov.uk/hadobs/hadisst/data/download.html here>
% (Rayner et al., 2003) which in full exceeds 200 MB.  If you'd like to perform the the same kind of analysis on a different region of the world,
% you can download the HadISST_sst.nc dataset and import it into Matlab like this.  Downsampling or subsetting the dataset are up to you: 
%  
%  % Load the full SST dataset: 
%  lat = double(ncread('HadISST_sst.nc','latitude')); 
%  lon = double(ncread('HadISST_sst.nc','longitude')); 
%  t = double(ncread('HadISST_sst.nc','time')+datenum(1870,1,0)); 
%  sst = ncread('HadISST_sst.nc','sst'); 
%  
%  % To quarter the size of the sample dataset, I crudely downsample to every other grid point: 
%  sst = sst(1:2:end,1:2:end,:); 
%  lat = lat(1:2:end); 
%  lon = lon(1:2:end); 
%  
%  % To further reduce size, I clipped to a range of lats and lons and kept only post-1950 data: 
%  rows = lon<-70; 
%  lon = lon(rows); 
%  cols = lat>=-60 & lat<=60; 
%  lat = lat(cols); 
%  times = t>=datenum('jan 1, 1950'); 
%  t = t(times); 
%  sst = sst(rows,cols,times); 
%  sst(sst<-50) = NaN; 
%  
%  % I find it easier to rearrange as lat x lon x time:
%  sst = permute(sst,[2 1 3]); 
%  
%  % Save the sample data:
%  save('PacOcean.mat','lat','lon','t','sst') 
% 
%% References 
% 
% Messi√©, Monique, and Francisco Chavez. "Global modes of sea surface temperature variability in relation to regional 
% climate indices." Journal of Climate 24.16 (2011): 4314-4331. <http://dx.doi.org/10.1175/2011JCLI3941.1 doi:10.1175/2011JCLI3941.1>.
%
% Rayner, N. A., Parker, D. E., Horton, E. B., Folland, C. K., Alexander, L. V., Rowell, D. P., Kent, E. C., Kaplan, A.  
% (2003). Global analyses of sea surface temperature, sea ice, and night marine air temperature since the late nineteenth century. 
% J. Geophys. Res.Vol. 108, No. D14, 4407 <http://dx.doi.org/10.1029/2002JD002670 doi:10.1029/2002JD002670>.
% 
% Thyng, K.M., C.A. Greene, R.D. Hetland, H.M. Zimmerle, and S.F. DiMarco. 2016. True colors of oceanography: Guidelines for
% effective and accurate colormap selection. Oceanography 29(3):9-13, <http://dx.doi.org/10.5670/oceanog.2016.66 doi:10.5670/oceanog.2016.66>.
% 
%% Author Info 
% The |eof| function was written by <http://www.chadagreene.com Chad A. Greene> of the University of Texas 
% Institute for Geophysics (UTIG) in January 2017, but leans heavily on Guillame MAZE's |caleof| function
% from his <https://www.mathworks.com/matlabcentral/fileexchange/17915 PCATool> contribution. This tutorial
% was written by Chad Greene with help from <https://www.kaustubh.info/ Kaustubh Thirumalai> also of the University 
% of Texas Institute for Geophysics. 
##### SOURCE END #####
--></body></html>